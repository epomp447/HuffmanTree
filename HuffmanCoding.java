import java.util.PriorityQueue;
import java.util.Scanner;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

public class HuffmanCoding {
	public static int n = 26;// size of alphabet

	// node class is the basic structure
	// of each node present in the huffman - tree.
	public static class HuffmanNode {

		int data;
		char symbol;

		HuffmanNode left;
		HuffmanNode right;

		HuffmanNode() {

		}

		HuffmanNode(char ch, int freq) {
			this.symbol = ch;
			this.data = freq;
		}

		void setSymbol(char ch) {
			this.symbol = ch;
		}

		void setFreq(int freq) {
			this.data = freq;
		}

		char getSymbol() {
			return symbol;
		}

		int getFreq() {
			return data;
		}

		public String toString() {
			String STR = "Symbol: " + this.getSymbol() + "\nFrequency: " + this.getFreq();
			return STR;
		}
	}

	// comparator class helps to compare the node
	// on the basis of one of its attribute.
	// Here we will be compared
	// on the basis of data values of the nodes.
	public static class MyComparator implements Comparator<HuffmanNode> {
		public int compare(HuffmanNode x, HuffmanNode y) {
			return x.data - y.data;
		}
	}

	// recursive function to print the
	// huffman-code through the tree traversal.
	// Here s is the huffman - code generated.
	public static void printCode(HuffmanNode root, String s) {

		// base case; if the left and right are null
		// then its a leaf node and we print
		// the code s generated by traversing the tree.
		if (root.left == null && root.right == null && Character.isLetter(root.symbol)) {

			// root.symbol is the character in the node
			System.out.println(root.symbol + ":" + s);
			code(root, s);// calls method to record node data in a "record" object
			return;
		}

		// recursive calls for left and
		// right sub-tree of the generated tree.
		// if we go to left then add "0" to the binary representation.
		printCode(root.left, s + "0");
		// if we go to the right add "1" to the binary representation.
		printCode(root.right, s + "1");

	}

	public static ArrayList<Record> record = new ArrayList<Record>();//array to hold the record of each HuffmanNode

	// method that records the Frequency, Symbol,
	// and binary representation each of huffmanNode
	public static void code(HuffmanNode root, String s) {

		Integer freq = root.getFreq();
		Character ch = root.getSymbol();
		String hc = s;
		Record r = new Record(ch, freq, hc);
		record.add(r);

		return;
	}


	public static PriorityQueue<HuffmanNode> huff(char[] ch, int[] f, int n) {
		// creating a priority queue q.
		// makes a min-priority queue(min-heap).
		PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator());

		for (int i = 0; i < n; i++) {

			// creating a huffmanNode object
			// and adding it to the priority-queue.
			HuffmanNode hn = new HuffmanNode();

			hn.symbol = ch[i];
			hn.data = f[i];

			hn.left = null;
			hn.right = null;

			// add functions adds
			// the huffman node to the queue.
			q.add(hn);

		}

		// System.out.println("Size: " + pq.size());
		// create a root node
		HuffmanNode root = null;

		// Here we will extract the two minimum value
		// from the heap each time until
		// its size reduces to 1, extract until
		// all the nodes are extracted.
		while (q.size() > 1) {

			// first min extract.
			HuffmanNode x = q.peek();
			q.poll();

			// second min extarct.
			HuffmanNode y = q.peek();
			q.poll();

			// new node f which is equal
			HuffmanNode sum = new HuffmanNode();

			// to the sum of the frequency of the two nodes
			// assigning values to the f node.
			sum.data = x.data + y.data;
			sum.symbol = '-';

			// first extracted node as left child.
			sum.left = x;

			// second extracted node as the right child.
			sum.right = y;

			// marking the f node as the root node.
			root = sum;

			// add this node to the priority-queue.
			q.add(sum);

		}
		return q;

	}

	public static void wepl(ArrayList<Record> recs) {

		int charWeights = 0;// frequency of each character
		double weightedAvg = 0;// sum of the frequency of each character
		int maxBitsASCII = 0;// number of bits required to encode an ASCII file
		int maxBitsUnicode = 0;// number of bits required to encode an Unicode file
		double bitsUsed = 0;// number of bits required to encode a 'huffman' file
		for (int i = 0; i < recs.size(); i++) {
			charWeights += recs.get(i).getFreq();
		}
		for (int i = 0; i < recs.size(); i++) {
			weightedAvg = (double) recs.get(i).getFreq() / charWeights;
			System.out.printf("AVG= " + recs.get(i).getSymbol() + " :   %.4f\n", weightedAvg);
		}
		for (int i = 0; i < recs.size(); i++) {
			int len = recs.get(i).getHuffman().length();
			System.out.println("Path Length: " + recs.get(i).getSymbol() + " = " + len);
		}
		for (int i = 0; i < recs.size(); i++) {
			bitsUsed += recs.get(i).getHuffman().length() * recs.get(i).getFreq();
			maxBitsASCII += recs.get(i).getFreq() * 8;// ASCII is 8 bit binary
			maxBitsUnicode += recs.get(i).getFreq() * 16;// Unicode is 16 bit binary

		}
		System.out.println("ASCII Bits Used : " + maxBitsASCII);
		System.out.println("Unicode Bits Used : " + maxBitsUnicode);
		System.out.println("Actual Bits Used= " + bitsUsed);
		double SavingsASCII = bitsUsed / maxBitsASCII;
		double SavingsUnicode = bitsUsed / maxBitsUnicode;
		System.out.printf("Space Savings Compared to ASCII= %.2f ", 100 - (SavingsASCII * 100));
		System.out.print("%\n");
		System.out.printf("Space Savings Compared to Unicode= %.2f ", 100 - (SavingsUnicode * 100));
		System.out.print("%\n");
	}

	static int COUNT = 10;// denotes the standard length of the indentation in each subsequent level of
							// the tree

	// Function to print binary tree horizontally
	// It does reverse inorder traversal
	// takes a reference to the root of a binary tree and
	// a space integer which will be used to indent the graphical
	// representation of the tree
	static void printTree(HuffmanNode root, int space) {
		// Base case
		if (root == null)
			return;

		// Increase indent between levels
		space += COUNT;

		// Process right child first
		printTree(root.right, space);

		// Print current node after space
		System.out.printf("\n");
		for (int i = COUNT; i < space; i++)
			System.out.printf(" ");
		System.out.printf(root.symbol + ",%d\n", root.data);

		// Process left child
		printTree(root.left, space);
	}

	// main function
	public static void main(String[] args) {
		System.out.println("\t Huffman Encoding  v1.2 \n\t by Evan Pomponio");
		System.out.println("Options:");
		System.out.println("\t(1) Run Demo");
		System.out.println("\t(2) Run with input.txt");
		Scanner scnr = new Scanner(System.in);
		int option = scnr.nextInt();

		if (option == 2) {
			Scanner inputStream = null;
			PrintWriter outputStream = null;
			try {
				inputStream = new Scanner(
						new FileInputStream("C:\\Users\\SuperSU\\Documents\\Java\\Trees\\src\\input.txt"));// input
//				outputStream = new PrintWriter(
//						new FileOutputStream("C:\\Users\\SuperSU\\Documents\\Java\\Trees\\src\\output.txt"));
			} catch (FileNotFoundException e) {// handle FileNotFoundException
				System.out.println("Problem opening files. Verify input.txt Path and retry");
				System.exit(0);
			}
			char ch;
			int freq;
			ArrayList<HuffmanNode> input = new ArrayList<HuffmanNode>();
			char[] arrayOfChar = new char[n];
			int[] arrayOfFreq = new int[n];
			int count = 0; // variable used to add to ArrayList Input
			while (inputStream.hasNextLine()) {
				ch = inputStream.next().charAt(0);
				freq = inputStream.nextInt();
				input.add(new HuffmanNode(ch, freq));
				input.get(count).setSymbol(ch);
				input.get(count).setFreq(freq);
				arrayOfChar[count] = ch;
				arrayOfFreq[count] = freq;
				// System.out.println(input.get(count).toString());
				//outputStream.println(input.get(count).toString());
				count++;
			}
			inputStream.close();
			//outputStream.close();
			PriorityQueue<HuffmanNode> huffPQ1 = huff(arrayOfChar, arrayOfFreq, arrayOfChar.length);
			printCode(huffPQ1.peek(), "");
			wepl(record);
			System.out.println("\t\n**************Huffman Tree**************\n\n");
			printTree(huffPQ1.peek(), 0);
			System.out.println("\n process completed");
		} else if (option == 1) {
			// System.out.println(arrayOfFreq.length == arrayOfChar.length);
			// PriorityQueue<HuffmanNode> huffPQ2 = huff(arrayOfChar, arrayOfFreq, n);

			char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' };
			int[] charFreq = { 45, 13, 12, 16, 9, 5 };

			huff(charArray, charFreq, charArray.length);

			PriorityQueue<HuffmanNode> huffPQ2 = huff(charArray, charFreq, charArray.length);
			//System.out.println("Size: " + huffPQ2.size());
			// huff2(charArray2, charFreq2, n);
			printCode(huffPQ2.peek(), "");
			wepl(record);
			System.out.println("\t**************Huffman Tree**************\n\n");
			printTree(huffPQ2.peek(), 0);
			System.out.println("\n process completed");
			// printCode(pq.peek(), "");
			// printTree(pq.peek(), 0);
			System.out.println();

		} else
			System.out.println("Invalid Input...exiting");
		System.exit(0);
	}
}