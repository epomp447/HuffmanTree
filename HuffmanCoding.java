
/**
*HuffmanCoding is an implementation of the popular algorithm
*for text compression
*
* <p>
*  Date: April 16, 2018
*</p>
*
* @author Evan Pomponio
* 
**/

import java.util.PriorityQueue;
import java.util.Scanner;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

public class HuffmanCoding {
	
	/*
	 * HuffmanNode class is the basic structure of each node present in the Huffman
	 * tree.
	 */
	public static class HuffmanNode {

		int data;
		char symbol;

		HuffmanNode left;
		HuffmanNode right;

		/**
		 * No argument constructor initializing all fields to zero.
		 */
		HuffmanNode() {
		}

		/**
		 * Constructor for HuffmanNode Object
		 * 
		 * @param symbol
		 * @param data
		 */
		HuffmanNode(char ch, int freq) {
			this.symbol = ch;
			this.data = freq;
		}

		/**
		 * mutator for symbol
		 * 
		 * @param symbol
		 **/
		void setSymbol(char ch) {
			this.symbol = ch;
		}

		/**
		 * mutator for frequency
		 * 
		 * @param data
		 **/
		void setFreq(int freq) {
			this.data = freq;
		}

		/**
		 * Accessor for symbol
		 * 
		 * @return char symbol
		 **/
		char getSymbol() {
			return symbol;
		}

		/**
		 * Accessor for frequency
		 * 
		 * @return int data
		 **/
		int getFreq() {
			return data;
		}

		/**
		 * Returns a string of instance Variables for HuffmanNode
		 * 
		 * @return String Format
		 */
		public String toString() {
			String STR = "Symbol: " + this.getSymbol() + "\nFrequency: " + this.getFreq();
			return STR;
		}
	}

	/**
	 * MyComparator class helps to compare the node on the basis of one of its
	 * attribute. Here we will make our comparison on the basis of data values of
	 * the nodes.
	 **/
	public static class MyComparator implements Comparator<HuffmanNode> {
		/**
		 * compare returns a negative if HuffmanNode x less than HuffmanNode y, 0 if
		 * they are equal, and a positive if HuffmanNode x greater than HuffmanNode y
		 * 
		 * @param HuffmanNode
		 *            x
		 * @param HuffmanNode
		 *            y
		 * @return int MyComparator
		 **/
		public int compare(HuffmanNode x, HuffmanNode y) {
			return x.data - y.data;
		}
	}

	/**
	 * Recursive function to print the Huffman Code through the tree traversal. Here
	 * s is the Huffman code generated. And root is a reference to the root of a
	 * binary tree.
	 * 
	 * @param root
	 * @param s
	 */
	public static void printCode(HuffmanNode root, String s) {

		// base case; if the left and right are null
		// then its a leaf node and we print
		// the code s generated by traversing the tree.
		if (root.left == null && root.right == null && Character.isLetter(root.symbol)) {

			// root.symbol is the character in the node
			System.out.println(root.symbol + ":" + s);
			code(root, s);// calls method to record node data in a "record" object
			return;
		}

		// recursive calls for left and
		// right sub-tree of the generated tree.
		// if we go to left then add "0" to the binary representation.
		printCode(root.left, s + "0");
		// if we go to the right add "1" to the binary representation.
		printCode(root.right, s + "1");

	}

	/**
	 * Array to hold the record of each HuffmanNode
	 */
	public static ArrayList<Record> record = new ArrayList<Record>();

	/**
	 * code Method that records the Frequency, Symbol, and Binary representation of 
	 * each HuffmanNode. 
	 * @param node
	 * @param s 
	 **/
	public static void code(HuffmanNode node, String s) {
		Integer freq = node.getFreq();
		Character ch = node.getSymbol();
		String hc = s;
		Record r = new Record(ch, freq, hc);
		record.add(r);
	}
	/**
	 * huff Method returns a reference to the Huffman tree for these keys with these frequencies
	 * by making a min-priority-queue(min-heap). 
	 * @param char [] ch
	 * @param int [] f
	 * @param int n
	 * @return PriorityQueue<HuffmanNode> q
	 **/
	public static PriorityQueue<HuffmanNode> huff(char[] ch, int[] f, int n) {
		// initializing a priority-queue q which takes arguments n which is the size of the alphabet.
		// and the Comparator that will be used to order this priority queue
		PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator());

		for (int i = 0; i < n; i++) {

			// creating a huffmanNode object
			// and adding it to the priority-queue.
			HuffmanNode hn = new HuffmanNode();

			hn.symbol = ch[i];
			hn.data = f[i];

			hn.left = null;
			hn.right = null;

			// add functions adds
			// the HuffmanMode to the queue.
			q.add(hn);

		}

		
		// create a root node
		HuffmanNode root = null;

		// Here we will extract the two minimum values
		// from the priority-queue each time until
		// its size reduces to 1, 
		while (q.size() > 1) {

			// first min extract.
			HuffmanNode x = q.poll();

			// second min extarct.
			HuffmanNode y = q.poll();

			// new node f which is equal
			HuffmanNode sum = new HuffmanNode();

			// to the sum of the frequency of the two nodes
			// assigning values to the f node.
			sum.data = x.data + y.data;
			sum.symbol = '-';

			// first extracted node as left child.
			sum.left = x;

			// second extracted node as the right child.
			sum.right = y;

			// marking the f node as the root node.
			root = sum;

			// add this node to the priority-queue.
			q.add(sum);

		}
		return q;
	}
	
/**
 * wepl function takes as parameter a reference to a binary tree and returns
 * the weighted average, path length of the leaves,
 * the percent saving in average bits per character over a fixed length binary code.
 * @param recs
 */
	public static void wepl(ArrayList<Record> recs) {

		int charWeights = 0;// frequency of each character
		double weightedAvg = 0;// sum of the frequency of each character
		int maxBitsASCII = 0;// number of bits required to encode an ASCII file
		int maxBitsUnicode = 0;// number of bits required to encode an Unicode file
		double bitsUsed = 0;// number of bits required to encode with Huffman algorithm
		for (int i = 0; i < recs.size(); i++) {
			charWeights += recs.get(i).getFreq();
		}
		System.out.println("\n\tWeighted Averages:");
		for (int i = 0; i < recs.size(); i++) {
			weightedAvg = (double) recs.get(i).getFreq() / charWeights;
			System.out.printf("AVG= " + recs.get(i).getSymbol() + " :   %.4f\n", weightedAvg);
		}
		System.out.println("\n\tPath Lengths:");
		for (int i = 0; i < recs.size(); i++) {
			int len = recs.get(i).getHuffman().length();
			System.out.println(recs.get(i).getSymbol() + " = " + len);
		}
		for (int i = 0; i < recs.size(); i++) {
			bitsUsed += recs.get(i).getHuffman().length() * recs.get(i).getFreq();
			maxBitsASCII += recs.get(i).getFreq() * 8;// ASCII is fixed length 8 bit binary
			maxBitsUnicode += recs.get(i).getFreq() * 16;// Unicode is fixed length 16 bit binary

		}
		System.out.println("ASCII Bits Used : " + maxBitsASCII);
		System.out.println("Unicode Bits Used : " + maxBitsUnicode);
		System.out.println("Actual Bits Used= " + bitsUsed);
		double SavingsASCII = bitsUsed / maxBitsASCII;
		double SavingsUnicode = bitsUsed / maxBitsUnicode;
		System.out.printf("Space Savings Compared to ASCII= %.2f ", 100 - (SavingsASCII * 100));
		System.out.print("%\n");
		System.out.printf("Space Savings Compared to Unicode= %.2f ", 100 - (SavingsUnicode * 100));
		System.out.print("%\n");
	}
/**
 * COUNT denotes the standard length of the indentation in each subsequent level of the tree
 */
	static final int COUNT = 10;

	/**
	 *  printTree function prints binary tree horizontally
	 *  It does reverse inorder traversal
	 *  takes a reference to the root of a binary tree and
	 *  a space integer which will be used to indent the graphical
	 *  representation of the tree
	 * @param root
	 * @param space
	 */
	static void printTree(HuffmanNode root, int space) {
		// Base case
		if (root == null)
			return;

		// Increase indent between levels
		space += COUNT;

		// Process right child first
		printTree(root.right, space);

		// Print current node after space
		System.out.printf("\n");
		for (int i = COUNT; i < space; i++)
			System.out.printf(" ");
		System.out.printf(root.symbol + ",%d\n", root.data);

		// Process left child
		printTree(root.left, space);
	}
	/**
	 * Size of alphabet
	 */
	public static int n = 26;
	// main function
	public static void main(String[] args) {
		System.out.println("\t Huffman Encoding  v1.3 \n\t by Evan Pomponio");
		System.out.println("Options:");
		System.out.println("\t(1) Run Demo");
		System.out.println("\t(2) Run with input.txt");
		Scanner scnr = new Scanner(System.in);
		int option = scnr.nextInt();

		if (option == 2) {
			Scanner inputStream = null;
			PrintWriter outputStream = null;
			try {
				inputStream = new Scanner(
						new FileInputStream("C:\\Users\\SuperSU\\Documents\\Java\\Trees\\src\\input.txt"));// input
				// outputStream = new PrintWriter( new FileOutputStream("C:\\Users\\SuperSU\\Documents\\Java\\Trees\\src\\output.txt"));
			} catch (FileNotFoundException e) {// handle FileNotFoundException
				System.out.println("Problem opening files. Verify input.txt Path and retry");
				System.exit(0);
			}
			char ch;
			int freq;
			ArrayList<HuffmanNode> input = new ArrayList<HuffmanNode>();
			char[] arrayOfChar = new char[n];
			int[] arrayOfFreq = new int[n];
			int count = 0; // variable used to add to ArrayList Input
			while (inputStream.hasNextLine()) {
				ch = inputStream.next().charAt(0);
				freq = inputStream.nextInt();
				input.add(new HuffmanNode(ch, freq));
				input.get(count).setSymbol(ch);
				input.get(count).setFreq(freq);
				arrayOfChar[count] = ch;
				arrayOfFreq[count] = freq;
				// System.out.println(input.get(count).toString());
				// outputStream.println(input.get(count).toString());
				count++;
			}
			inputStream.close();
			// outputStream.close();
			
			PriorityQueue<HuffmanNode> huffPQ1 = huff(arrayOfChar, arrayOfFreq, arrayOfChar.length);
			
			printCode(huffPQ1.peek(), "");
			wepl(record);
			System.out.println("\t\n**************Huffman Tree**************\n\n");
			printTree(huffPQ1.peek(), 0);
			System.out.println("\n process completed");
		} else if (option == 1) {
			// System.out.println(arrayOfFreq.length == arrayOfChar.length);
			// PriorityQueue<HuffmanNode> huffPQ2 = huff(arrayOfChar, arrayOfFreq, n);

			char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' };
			int[] charFreq = { 45, 13, 12, 16, 9, 5 };

			huff(charArray, charFreq, charArray.length);

			PriorityQueue<HuffmanNode> huffPQ2 = huff(charArray, charFreq, charArray.length);
			// System.out.println("Size: " + huffPQ2.size());
			// huff2(charArray2, charFreq2, n);
			printCode(huffPQ2.peek(), "");
			wepl(record);
			System.out.println("\t**************Huffman Tree**************\n\n");
			printTree(huffPQ2.peek(), 0);
			System.out.println("\n process completed");
			// printCode(pq.peek(), "");
			// printTree(pq.peek(), 0);
			System.out.println();

		} else
			System.out.println("Invalid Input...exiting");
		System.exit(0);
	}
}