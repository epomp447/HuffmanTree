import java.util.PriorityQueue;
import java.util.Scanner;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

public class Huffman {
	public static int n = 26;

	// node class is the basic structure
	// of each node present in the huffman - tree.
	public static class HuffmanNode  {

		int data;
		char symbol;

		HuffmanNode left;
		HuffmanNode right;

		HuffmanNode() {
			
		}

		HuffmanNode(char ch, int freq) {
			this.symbol = ch;
			this.data = freq;
		}

		void setSymbol(char ch) {
			this.symbol = ch;
		}

		void setFreq(int freq) {
			this.data = freq;
		}

		char getSymbol() {
			return symbol;
		}

		int getFreq() {
			return data;
		}

		public String toString() {
			String STR = "Symbol: " + this.getSymbol() + "\nFrequency: " + this.getFreq();
			return STR;
		}
	}

	// comparator class helps to compare the node
	// on the basis of one of its attribute.
	// Here we will be compared
	// on the basis of data values of the nodes.
	public static class MyComparator implements Comparator<HuffmanNode> {
		public int compare(HuffmanNode x, HuffmanNode y) {
			return x.data - y.data;
		}
	}

	// recursive function to print the
	// huffman-code through the tree traversal.
	// Here s is the huffman - code generated.
	public static void printCode(HuffmanNode root, String s) {

		// base case; if the left and right are null
		// then its a leaf node and we print
		// the code s generated by traversing the tree.
		if (root.left == null && root.right == null && Character.isLetter(root.symbol)) {

			// root.symbol is the character in the node
			System.out.println(root.symbol + ":" + s);

			// System.out.println("s= "+s);
			code(root, s);
			// records.add(s);
			return;
		}

		// if we go to left then add "0" to the code.
		// if we go to the right add"1" to the code.

		// recursive calls for left and
		// right sub-tree of the generated tree.
		printCode(root.left, s + "0");
		printCode(root.right, s + "1");

	}

	public static ArrayList<Record> record = new ArrayList<Record>();

	public static void code(HuffmanNode root, String s) {

		Integer freq = root.getFreq();
		Character ch = root.getSymbol();
		String hc = s;
		Record r = new Record(ch, freq, hc);
		record.add(r);

		return;
	}

	public static PriorityQueue<HuffmanNode> pq = new PriorityQueue<HuffmanNode>(n, new MyComparator());// global
																										// priority
																										// queue

	public static PriorityQueue<HuffmanNode> huff(char[] ch, int[] f, int n) {
		// creating a priority queue q.
		// makes a min-priority queue(min-heap).
		PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator());

		for (int i = 0; i < n; i++) {

			// creating a huffman node object
			// and adding it to the priority-queue.
			HuffmanNode hn = new HuffmanNode();

			hn.symbol = ch[i];
			hn.data = f[i];

			hn.left = null;
			hn.right = null;

			// add functions adds
			// the huffman node to the queue.
			q.add(hn);
			pq.add(hn);
		}

		// System.out.println("Size: " + pq.size());
		// create a root node
		HuffmanNode root = null;

		// Here we will extract the two minimum value
		// from the heap each time until
		// its size reduces to 1, extract until
		// all the nodes are extracted.
		while (q.size() > 1) {

			// first min extract.
			HuffmanNode x = q.peek();
			q.poll();
			pq.poll();
			// second min extarct.
			HuffmanNode y = q.peek();
			q.poll();
			pq.poll();
			// new node f which is equal
			HuffmanNode sum = new HuffmanNode();

			// to the sum of the frequency of the two nodes
			// assigning values to the f node.
			sum.data = x.data + y.data;
			sum.symbol = '-';

			// first extracted node as left child.
			sum.left = x;

			// second extracted node as the right child.
			sum.right = y;

			// marking the f node as the root node.
			root = sum;

			// add this node to the priority-queue.
			q.add(sum);
			pq.add(sum);
		}

		// print the codes by traversing the tree
		// printCode(root, "");
		// printLevelOrder(root);
		return q;
	}

	public static void wepl(ArrayList<Record> recs) {

		int sumOfWeights = 0;
		double weightedAvg = 0;
		int maxBits = recs.size() * 8;
		double bitsUsed = 0;
		for (int i = 0; i < recs.size(); i++) {
			sumOfWeights += +recs.get(i).getFreq();
		}
		for (int i = 0; i < recs.size(); i++) {
			weightedAvg = (double) recs.get(i).getFreq() / sumOfWeights;
			System.out.printf("AVG= " + recs.get(i).getSymbol() + " :   %.4f\n", weightedAvg);
		}
		for (int i = 0; i < recs.size(); i++) {
			int len = recs.get(i).getHuffman().length();
			System.out.println("Path Length: " + recs.get(i).getSymbol() + " = " + (len - 1));
		}
		for (int i = 0; i < recs.size(); i++) {
			bitsUsed += recs.get(i).getHuffman().length();

		}
		System.out.println("Bits Used= " + bitsUsed);
		double SavingsASCII=bitsUsed / maxBits;
		System.out.printf("Percent Savings Compared to ASCII= %.2f \n" , SavingsASCII*100);
	}

	static int COUNT = 10;

	// Function to print binary tree in 2D
	// It does reverse inorder traversal
	static void printTree(HuffmanNode root, int space) {
		// Base case
		if (root == null)
			return;

		// Increase distance between levels
		space += COUNT;

		// Process right child first
		printTree(root.right, space);

		// Print current node after space
		// count
		System.out.printf("\n");
		for (int i = COUNT; i < space; i++)
			System.out.printf(" ");
		System.out.printf(root.symbol + ",%d\n", root.data);

		// Process left child
		printTree(root.left, space);
	}

	

	// main function/Trees/src/input
	public static void main(String[] args) {

//		Scanner inputStream = null;
//		PrintWriter outputStream = null;
//		try {
//			inputStream = new Scanner(new FileInputStream("C:\\Users\\SuperSU\\Documents\\Java\\Trees\\src\\input(2).txt"));// input
//			//outputStream = new PrintWriter(new FileOutputStream("C:\\Users\\SuperSU\\Documents\\Java\\Trees\\src\\output.txt"));
//		} catch (FileNotFoundException e) {
//			System.out.println("Problem opening files");
//			 System.exit(0);
//		}
//		char ch;
//		int freq;
//		ArrayList<HuffmanNode> input = new ArrayList<HuffmanNode>();
//		char[] arrayOfChar = new char[n];
//		int[] arrayOfFreq = new int[n];
//		int count = 0; // variable used to add to ArrayList Input
//		while (inputStream.hasNextLine()) {
//			ch = inputStream.next().charAt(0);
//			freq = inputStream.nextInt();
//			input.add(new HuffmanNode(ch, freq));
//			input.get(count).setSymbol(ch);
//			input.get(count).setFreq(freq);
//			arrayOfChar[count] = ch;
//			arrayOfFreq[count] = freq;
//			//System.out.println(input.get(count).toString());
//			//outputStream.println(input.get(count).toString());
//			count++;
//		}
//		inputStream.close();
//		//outputStream.close();
//		System.out.println(Arrays.toString(arrayOfChar));
//		System.out.println(Arrays.toString(arrayOfFreq));
//		System.out.println(arrayOfFreq.length == arrayOfChar.length);
//		PriorityQueue<HuffmanNode> huffPQ2 = huff(arrayOfChar, arrayOfFreq, n);

		 char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' };
		 int[] charFreq = { 5, 9, 12, 13, 16, 45 };
		 char[] charArray2 = { 'd', 'e', 'f', 'g', 'h', 'i' };
		 int[] charFreq2 = { 5, 7, 10, 15, 20, 45 };
		 PriorityQueue<HuffmanNode> huffPQ = huff(charArray, charFreq, charArray.length);
		 System.out.println("Size: " + pq.size());
		// PriorityQueue<HuffmanNode> huffPQ2 = huff(charArray2, charFreq2, n);
		
		printCode(pq.peek(), "");
		wepl(record);
		printTree(pq.peek(), 0);
		System.out.println();

	}
}