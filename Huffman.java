import java.util.PriorityQueue;
import java.util.Scanner;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;

public class Huffman implements Serializable {
	public static int n = 26;

	// node class is the basic structure
	// of each node present in the huffman - tree.
	public static class HuffmanNode implements Serializable {

		int data;
		char symbol;

		HuffmanNode left;
		HuffmanNode right;

		public int getFreq() {
			return data;
		}

		public char getSymbol() {
			return symbol;
		}
	}

	// comparator class helps to compare the node
	// on the basis of one of its attribute.
	// Here we will be compared
	// on the basis of data values of the nodes.
	public static class MyComparator implements Comparator<HuffmanNode> {
		public int compare(HuffmanNode x, HuffmanNode y) {

			return x.data - y.data;
		}
	}

	// recursive function to print the
	// huffman-code through the tree traversal.
	// Here s is the huffman - code generated.
	public static void printCode(HuffmanNode root, String s) {

		// base case; if the left and right are null
		// then its a leaf node and we print
		// the code s generated by traversing the tree.
		if (root.left == null && root.right == null && Character.isLetter(root.symbol)) {

			// root.symbol is the character in the node
			System.out.println(root.symbol + ":" + s);

			// System.out.println("s= "+s);
			code(root, s);
			// records.add(s);
			return;
		}

		// if we go to left then add "0" to the code.
		// if we go to the right add"1" to the code.

		// recursive calls for left and
		// right sub-tree of the generated tree.
		printCode(root.left, s + "0");
		printCode(root.right, s + "1");

	}

	public static ArrayList<Record> record = new ArrayList<Record>();

	public static void code(HuffmanNode root, String s) {

		Integer freq = root.getFreq();
		Character ch = root.getSymbol();
		String hc = s;
		Record r = new Record(ch, freq, hc);
		record.add(r);

		return;
	}

	public static PriorityQueue<HuffmanNode> pq = new PriorityQueue<HuffmanNode>(n, new MyComparator());// global
																										// priority
																										// queue

	public static PriorityQueue<HuffmanNode> huff(char[] ch, int[] f, int n) {
		// creating a priority queue q.
		// makes a min-priority queue(min-heap).
		PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator());

		for (int i = 0; i < n; i++) {

			// creating a huffman node object
			// and adding it to the priority-queue.
			HuffmanNode hn = new HuffmanNode();

			hn.symbol = ch[i];
			hn.data = f[i];

			hn.left = null;
			hn.right = null;

			// add functions adds
			// the huffman node to the queue.
			q.add(hn);
			pq.add(hn);
		}

		// System.out.println("Size: " + pq.size());
		// create a root node
		HuffmanNode root = null;

		// Here we will extract the two minimum value
		// from the heap each time until
		// its size reduces to 1, extract until
		// all the nodes are extracted.
		while (q.size() > 1) {

			// first min extract.
			HuffmanNode x = q.peek();
			q.poll();
			pq.poll();
			// second min extarct.
			HuffmanNode y = q.peek();
			q.poll();
			pq.poll();
			// new node f which is equal
			HuffmanNode sum = new HuffmanNode();

			// to the sum of the frequency of the two nodes
			// assigning values to the f node.
			sum.data = x.data + y.data;
			sum.symbol = '-';

			// first extracted node as left child.
			sum.left = x;

			// second extracted node as the right child.
			sum.right = y;

			// marking the f node as the root node.
			root = sum;

			// add this node to the priority-queue.
			q.add(sum);
			pq.add(sum);
		}

		// print the codes by traversing the tree
		// printCode(root, "");
		// printLevelOrder(root);
		return q;
	}

	public static void wepl(ArrayList<Record> recs) {

		int sumOfWeights = 0;
		double weightedAvg = 0;
		int maxBits = recs.size() * 8;
		double bitsUsed = 0;
		for (int i = 0; i < recs.size(); i++) {
			sumOfWeights += +recs.get(i).getFreq();
		}
		for (int i = 0; i < recs.size(); i++) {
			weightedAvg = (double) recs.get(i).getFreq() / sumOfWeights;
			System.out.printf("AVG= " + recs.get(i).getSymbol() + " :   %.2f\n", weightedAvg);
		}
		for (int i = 0; i < recs.size(); i++) {
			int len = recs.get(i).getHuffman().length();
			System.out.println("Path Length: " + recs.get(i).getSymbol() + " = " + (len - 1));
		}
		for (int i = 0; i < recs.size(); i++) {
			bitsUsed += recs.get(i).getHuffman().length();

		}
		System.out.println("Bits Used= " + bitsUsed);
		double SavingsASCII=bitsUsed / maxBits;
		System.out.printf("Percent Savings Compared to ASCII= %.2f \n" , SavingsASCII*100);
	}

	static int COUNT = 10;

	// Function to print binary tree in 2D
	// It does reverse inorder traversal
	static void print2DUtil(HuffmanNode root, int space) {
		// Base case
		if (root == null)
			return;

		// Increase distance between levels
		space += COUNT;

		// Process right child first
		print2DUtil(root.right, space);

		// Print current node after space
		// count
		System.out.printf("\n");
		for (int i = COUNT; i < space; i++)
			System.out.printf(" ");
		System.out.printf(root.symbol + ",%d\n", root.data);

		// Process left child
		print2DUtil(root.left, space);
	}

	public static class text {
		char c;
		int f;

		text(char ch, int freq) {
			this.c = ch;
			this.f = freq;
		}

		void setSymbol(char ch) {
			this.c = ch;
		}

		void setFreq(int freq) {
			this.f = freq;
		}

		char getSymbol() {
			return c;
		}

		int getFreq() {
			return f;
		}

		public String toString() {
			String STR = "Symbol: " + this.getSymbol() + "\nFrequency: " + this.getFreq();
			return STR;
		}
	}

	// main function/Trees/src/input
	public static void main(String[] args) {

		Scanner inputStream = null;
		PrintWriter outputStream = null;
		try {
			inputStream = new Scanner(new FileInputStream("C:\\..\\...\\src\\input.txt"));// input
			//outputStream = new PrintWriter(new FileOutputStream("C:\\..\\...\\src\\output.txt"));
		} catch (FileNotFoundException e) {
			System.out.println("Problem opening files");
			// System.exit(0);
		}
		char ch;
		int freq;
		ArrayList<text> input = new ArrayList<text>();
		char[] arrayOfChar = new char[n];
		int[] arrayOfFreq = new int[n];
		int count = 0; // variable used to add to ArrayList Input
		while (inputStream.hasNextLine()) {
			ch = inputStream.next().charAt(0);
			freq = inputStream.nextInt();
			input.add(new text(ch, freq));
			input.get(count).setSymbol(ch);
			input.get(count).setFreq(freq);
			arrayOfChar[count] = ch;
			arrayOfFreq[count] = freq;
			//System.out.println(input.get(count).toString());
			//outputStream.println(input.get(count).toString());
			count++;
		}
		inputStream.close();
		//outputStream.close();
		System.out.println(Arrays.toString(arrayOfChar));
		System.out.println(Arrays.toString(arrayOfFreq));
		System.out.println(arrayOfFreq.length == arrayOfChar.length);
		PriorityQueue<HuffmanNode> huffPQ2 = huff(arrayOfChar, arrayOfFreq, n);

		// char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' };
		// int[] charFreq = { 5, 9, 12, 13, 16, 45 };
		//
		// char[] charArray2 = { 'd', 'e', 'f', 'g', 'h', 'i' };
		// int[] charFreq2 = { 5, 7, 10, 15, 20, 45 };
		// PriorityQueue<HuffmanNode> huffPQ = huff(charArray, charFreq,
		// charArray.length);
		// System.out.println("Size: " + pq.size());
		// PriorityQueue<HuffmanNode> huffPQ2 = huff(charArray2, charFreq2, n);
		//
		printCode(pq.peek(), "");
		wepl(record);
		print2DUtil(pq.peek(), 0);
		System.out.println();

	}
}
