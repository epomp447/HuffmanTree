import java.util.PriorityQueue;
import java.util.Scanner;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Comparator;


public class Huffman implements Serializable {
	public static int n = 6;
	public static ArrayList<String> wepl;

	// node class is the basic structure
	// of each node present in the huffman - tree.
	public static class HuffmanNode implements Serializable {

		int data;
		char symbol;

		HuffmanNode left;
		HuffmanNode right;

		public int getFreq() {
			return data;
		}

		public char getSymbol() {
			return symbol;
		}
	}

	// comparator class helps to compare the node
	// on the basis of one of its attribute.
	// Here we will be compared
	// on the basis of data values of the nodes.
	public static class MyComparator implements Comparator<HuffmanNode> {
		public int compare(HuffmanNode x, HuffmanNode y) {

			return x.data - y.data;
		}
	}

	// recursive function to print the
	// huffman-code through the tree traversal.
	// Here s is the huffman - code generated.
	public static void printCode(HuffmanNode root, String s) {
	

		// base case; if the left and right are null
		// then its a leaf node and we print
		// the code s generated by traversing the tree.
		if (root.left == null && root.right == null && Character.isLetter(root.symbol)) {

			// c is the character in the node
			System.out.println(root.symbol + ":" + s);
			// System.out.println(s);
			// System.out.println("s= "+s);
			// String str=s;
			code(root, s);
			// records.add(s);
			return;
		}

		// if we go to left then add "0" to the code.
		// if we go to the right add"1" to the code.

		// recursive calls for left and
		// right sub-tree of the generated tree.
		printCode(root.left, s + "0");
		printCode(root.right, s + "1");

	}

	public static ArrayList<String> record = new ArrayList<String>();
	public static ArrayList<Record> code = new ArrayList<Record>();

	public static void code(HuffmanNode root, String s) {

		Integer freq = root.getFreq();
		Character ch = root.getSymbol();
		String hc = s;
		Record r = new Record(ch, freq, hc);
		code.add(r);

		String f = freq.toString();
		String c = ch.toString();

		return;
	}

	public static PriorityQueue<HuffmanNode> huff(char[] ch, int[] f, int n) {
		// creating a priority queue q.
		// makes a min-priority queue(min-heap).
		PriorityQueue<HuffmanNode> q = new PriorityQueue<HuffmanNode>(n, new MyComparator());

		for (int i = 0; i < n; i++) {

			// creating a huffman node object
			// and adding it to the priority-queue.
			HuffmanNode hn = new HuffmanNode();

			hn.symbol = ch[i];
			hn.data = f[i];

			hn.left = null;
			hn.right = null;

			// add functions adds
			// the huffman node to the queue.
			q.add(hn);
		}

		// create a root node
		HuffmanNode root = null;

		// Here we will extract the two minimum value
		// from the heap each time until
		// its size reduces to 1, extract until
		// all the nodes are extracted.
		while (q.size() > 1) {

			// first min extract.
			HuffmanNode x = q.peek();
			q.poll();

			// second min extarct.
			HuffmanNode y = q.peek();
			q.poll();

			// new node f which is equal
			HuffmanNode sum = new HuffmanNode();

			// to the sum of the frequency of the two nodes
			// assigning values to the f node.
			sum.data = x.data + y.data;
			sum.symbol = '-';

			// first extracted node as left child.
			sum.left = x;

			// second extracted node as the right child.
			sum.right = y;

			// marking the f node as the root node.
			root = sum;

			// add this node to the priority-queue.
			q.add(sum);
		}
		// print the codes by traversing the tree
		printCode(root, "");
		return q;
	}

	public static void wepl(ArrayList<Record> recs) {

		int sumOfWeights = 0;
		double weightedAvg = 0;
		int maxBits = recs.size() * 8;
		double bitsUsed = 0;
		for (int i = 0; i < recs.size(); i++) {
			sumOfWeights += +recs.get(i).getFreq();
		}
		for (int i = 0; i < recs.size(); i++) {
			weightedAvg = (double) recs.get(i).getFreq() / sumOfWeights;
			System.out.println("AVG= " + recs.get(i).getSymbol() + " : " + weightedAvg);
		}
		for (int i = 0; i < recs.size(); i++) {
			int len = recs.get(i).getHuffman().length();
			System.out.println("Path Length: " +recs.get(i).getSymbol() + " = " + len);
		}
		for (int i = 0; i < recs.size(); i++) {

			bitsUsed += recs.get(i).getHuffman().length();

		}
		System.out.println("Bits Used= " + bitsUsed);
		System.out.println("Compression Rate= " + bitsUsed / maxBits);
	}

	// main function
	public static void main(String[] args) {

		Scanner s = new Scanner(System.in);

		// number of characters.
		// int n = 6;
		char[] charArray = { 'a', 'b', 'c', 'd', 'e', 'f' };
		int[] charFreq = { 5, 9, 12, 13, 16, 45 };
		// huff(charArray, charFreq, n);

		PriorityQueue<HuffmanNode> huffPQ = huff(charArray, charFreq, n);
		// for (int i = 0; i < n; i++) {
		// System.out.println(code.get(i));
		// }
		wepl(code);
		System.out.println();

	}
}